import { v } from "convex/values"

import type { Id } from "./_generated/dataModel"
import { action, internalMutation, internalQuery, mutation, query } from "./_generated/server"
import { internal } from "./_generated/api"
import { dbscan, haversineDistance, convexHull } from "./lib/dbscan"
import type { GeoPoint } from "./lib/dbscan"

export const list = query({
  args: {},
  handler: async (ctx) => {
    const clusters = await ctx.db.query("clusters").collect()
    const clustersWithCounts = await Promise.all(
      clusters.map(async (cluster) => {
        const leads = await ctx.db
          .query("leads")
          .withIndex("by_clusterId", (q) => q.eq("clusterId", cluster._id))
          .collect()
        return { ...cluster, leadCount: leads.length }
      })
    )
    return clustersWithCounts
  },
})

export const getLeads = query({
  args: {
    clusterId: v.id("clusters"),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("leads")
      .withIndex("by_clusterId", (q) => q.eq("clusterId", args.clusterId))
      .collect()
  },
})

export const updateName = mutation({
  args: {
    clusterId: v.id("clusters"),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.clusterId, { name: args.name })
  },
})

export const update = mutation({
  args: {
    clusterId: v.id("clusters"),
    name: v.optional(v.string()),
    radiusKm: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const patch: Record<string, string | number> = {}
    if (args.name !== undefined) {
      patch.name = args.name
    }
    if (args.radiusKm !== undefined) {
      patch.radiusKm = args.radiusKm
    }
    if (Object.keys(patch).length > 0) {
      await ctx.db.patch(args.clusterId, patch)
    }
  },
})

export const deleteAllClusters = mutation({
  args: {},
  handler: async (ctx) => {
    const clusters = await ctx.db.query("clusters").collect()
    for (const cluster of clusters) {
      await ctx.db.delete(cluster._id)
    }

    const leads = await ctx.db.query("leads").collect()
    const now = Date.now()
    let leadsPatched = 0
    for (const lead of leads) {
      if (lead.clusterId !== undefined) {
        await ctx.db.patch(lead._id, { clusterId: undefined, updatedAt: now })
        leadsPatched++
      }
    }

    return { clustersDeleted: clusters.length, leadsPatched }
  },
})

// --- Internal helpers for autoGenerate ---

export const getLeadsWithCoords = internalQuery({
  args: {},
  handler: async (ctx) => {
    const leads = await ctx.db.query("leads").collect()
    return leads
      .filter((l) => l.latitude !== undefined && l.longitude !== undefined)
      .map((l) => ({
        _id: l._id,
        latitude: l.latitude as number,
        longitude: l.longitude as number,
        city: l.city,
        clusterId: l.clusterId,
      }))
  },
})

export const getAllLeadIds = internalQuery({
  args: {},
  handler: async (ctx) => {
    const leads = await ctx.db.query("leads").collect()
    return leads.map((l) => ({ _id: l._id, clusterId: l.clusterId }))
  },
})

export const deleteAutoGeneratedClusters = internalMutation({
  args: {},
  handler: async (ctx) => {
    const clusters = await ctx.db.query("clusters").collect()
    const autoGenerated = clusters.filter((c) => c.isAutoGenerated)
    for (const cluster of autoGenerated) {
      await ctx.db.delete(cluster._id)
    }
    return autoGenerated.map((c) => c._id)
  },
})

export const createCluster = internalMutation({
  args: {
    name: v.string(),
    boundary: v.array(v.object({ lat: v.number(), lng: v.number() })),
    centerLat: v.number(),
    centerLng: v.number(),
    radiusKm: v.number(),
    leadCount: v.number(),
    isAutoGenerated: v.boolean(),
  },
  handler: async (ctx, args) => {
    const doc = {
      name: args.name,
      boundary: args.boundary as Array<{ lat: number; lng: number }>,
      centerLat: args.centerLat,
      centerLng: args.centerLng,
      radiusKm: args.radiusKm,
      leadCount: args.leadCount,
      isAutoGenerated: args.isAutoGenerated,
    }
    return await ctx.db.insert("clusters", doc)
  },
})

export const assignLeadsToCluster = internalMutation({
  args: {
    leadIds: v.array(v.id("leads")),
    clusterId: v.id("clusters"),
    clusterName: v.string(),
  },
  handler: async (ctx, args) => {
    const now = Date.now()
    for (const leadId of args.leadIds) {
      await ctx.db.patch(leadId, {
        clusterId: args.clusterId,
        updatedAt: now,
      })
      await ctx.db.insert("activities", {
        leadId,
        type: "note_added",
        description: `Auto-assigned to cluster "${args.clusterName}"`,
        metadata: {
          clusterId: args.clusterId,
          clusterName: args.clusterName,
          autoGenerated: true,
        },
        createdAt: now,
      })
    }
  },
})

export const clearLeadCluster = internalMutation({
  args: {
    leadIds: v.array(v.id("leads")),
  },
  handler: async (ctx, args) => {
    const now = Date.now()
    for (const leadId of args.leadIds) {
      await ctx.db.patch(leadId, {
        clusterId: undefined,
        updatedAt: now,
      })
    }
  },
})

// --- Main action ---

export const autoGenerate = action({
  args: {},
  handler: async (ctx) => {
    // Work around Convex TS2589 caused by nested boundary validator
    // @ts-expect-error Type instantiation too deep with nested boundary validator
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const internalRef = internal as Record<string, Record<string, any>>

    // 1. Fetch all leads with coordinates
    const leadsWithCoords = await ctx.runQuery(
      internalRef.clusters.getLeadsWithCoords,
      {},
    ) as Array<{
      _id: Id<"leads">
      latitude: number
      longitude: number
      city: string
      clusterId?: Id<"clusters">
    }>

    // 2. Delete existing auto-generated clusters
    const deletedClusterIds = await ctx.runMutation(
      internalRef.clusters.deleteAutoGeneratedClusters,
      {},
    ) as Id<"clusters">[]

    // 3. Clear clusterId on leads that were in deleted auto-generated clusters
    const allLeads = await ctx.runQuery(
      internalRef.clusters.getAllLeadIds,
      {},
    ) as Array<{ _id: Id<"leads">; clusterId?: Id<"clusters"> }>

    const deletedSet = new Set(deletedClusterIds as string[])
    const leadsToUnassign = allLeads
      .filter((l) => l.clusterId && deletedSet.has(l.clusterId as string))
      .map((l) => l._id)

    if (leadsToUnassign.length > 0) {
      await ctx.runMutation(internalRef.clusters.clearLeadCluster, {
        leadIds: leadsToUnassign,
      })
    }

    // 4. Run DBSCAN
    const points: GeoPoint[] = leadsWithCoords.map((l) => ({
      id: l._id as string,
      lat: l.latitude,
      lng: l.longitude,
      city: l.city,
    }))

    const clusters = dbscan(points)

    if (clusters.length === 0) {
      return { clustersCreated: 0, leadsAssigned: 0, leadsUnassigned: leadsToUnassign.length }
    }

    // 5. For each cluster: calculate center, radius, create record, assign leads
    let totalAssigned = 0

    for (const cluster of clusters) {
      const memberPoints = points.filter((p) => cluster.pointIds.includes(p.id))

      // Boundary = convex hull of member points
      const boundary = convexHull(
        memberPoints.map((p) => ({ lat: p.lat, lng: p.lng })),
      )

      // Center = average lat/lng (polygon centroid approximation)
      const centerLat = memberPoints.reduce((sum, p) => sum + p.lat, 0) / memberPoints.length
      const centerLng = memberPoints.reduce((sum, p) => sum + p.lng, 0) / memberPoints.length

      // Radius = max distance from center to any member (bounding radius for zoom fitting)
      let radiusKm = 0
      for (const p of memberPoints) {
        const dist = haversineDistance(centerLat, centerLng, p.lat, p.lng)
        if (dist > radiusKm) radiusKm = dist
      }
      // Minimum radius of 1km for display purposes
      radiusKm = Math.max(radiusKm, 1)

      const clusterId = await ctx.runMutation(internalRef.clusters.createCluster, {
        name: cluster.name,
        boundary,
        centerLat,
        centerLng,
        radiusKm,
        leadCount: cluster.pointIds.length,
        isAutoGenerated: true,
      }) as Id<"clusters">

      const leadIds = cluster.pointIds.map((id) => id as Id<"leads">)

      await ctx.runMutation(internalRef.clusters.assignLeadsToCluster, {
        leadIds,
        clusterId,
        clusterName: cluster.name,
      })

      totalAssigned += leadIds.length
    }

    return {
      clustersCreated: clusters.length,
      leadsAssigned: totalAssigned,
      leadsUnassigned: leadsToUnassign.length,
    }
  },
})
