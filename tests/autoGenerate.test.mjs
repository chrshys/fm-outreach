import assert from "node:assert/strict";
import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import test from "node:test";
import { createRequire } from "node:module";

import ts from "typescript";

function loadPointInPolygon() {
  const source = fs.readFileSync("convex/lib/pointInPolygon.ts", "utf8");
  const transpiled = ts.transpileModule(source, {
    compilerOptions: {
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.ES2022,
      esModuleInterop: true,
    },
    fileName: "pointInPolygon.ts",
  }).outputText;

  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "fm-pip-"));
  const modulePath = path.join(tempDir, "pointInPolygon.cjs");
  fs.writeFileSync(modulePath, transpiled, "utf8");

  const requireFromTest = createRequire(import.meta.url);

  try {
    return requireFromTest(modulePath);
  } finally {
    fs.rmSync(tempDir, { recursive: true, force: true });
  }
}

const source = fs.readFileSync("convex/clusters.ts", "utf8");

// --- createPolygonCluster source structure tests ---

test("createPolygonCluster is exported as a mutation", () => {
  assert.match(source, /export\s+const\s+createPolygonCluster\s*=\s*mutation\(/);
});

test("createPolygonCluster takes name and boundary args", () => {
  assert.match(source, /name:\s*v\.string\(\)/);
  assert.match(
    source,
    /boundary:\s*v\.array\(v\.object\(\{\s*lat:\s*v\.number\(\),\s*lng:\s*v\.number\(\)\s*\}\)\)/,
  );
});

test("createPolygonCluster computes centroid via polygonCentroid", () => {
  assert.match(source, /polygonCentroid\(boundary\)/);
});

test("createPolygonCluster computes bounding radius via boundingRadius", () => {
  assert.match(source, /boundingRadius\(centroid,\s*boundary\)/);
});

test("createPolygonCluster enforces minimum 1km radius", () => {
  assert.match(source, /Math\.max\(radius,\s*1\)/);
});

test("createPolygonCluster queries all leads and filters by coordinates", () => {
  assert.match(source, /ctx\.db\.query\("leads"\)\.collect\(\)/);
  assert.match(source, /l\.latitude !== undefined && l\.longitude !== undefined/);
});

test("createPolygonCluster uses pointInPolygon to find enclosed leads", () => {
  assert.match(source, /pointInPolygon\(/);
});

test("createPolygonCluster inserts cluster doc with isAutoGenerated: false", () => {
  assert.match(source, /isAutoGenerated:\s*false/);
  assert.match(source, /ctx\.db\.insert\("clusters"/);
});

test("createPolygonCluster patches enclosed leads with clusterId", () => {
  assert.match(source, /ctx\.db\.patch\(lead\._id/);
  assert.match(source, /clusterId/);
});

test("createPolygonCluster logs activity on each assigned lead", () => {
  assert.match(source, /ctx\.db\.insert\("activities"/);
  assert.match(source, /type:\s*"note_added"/);
  assert.match(source, /Assigned to cluster/);
});

test("createPolygonCluster returns clusterId and leadCount", () => {
  assert.match(source, /return\s*\{[\s\S]*?clusterId[\s\S]*?leadCount[\s\S]*?\}/);
});

test("clusters.ts imports from pointInPolygon, not dbscan", () => {
  assert.match(source, /from\s+"\.\/lib\/pointInPolygon"/);
  assert.ok(
    !source.includes("./lib/dbscan"),
    "Should not import from dbscan",
  );
});

test("clusters.ts does not export autoGenerate", () => {
  assert.ok(
    !source.includes("export const autoGenerate"),
    "autoGenerate should be removed",
  );
});

test("clusters.ts does not reference dbscan or DBSCAN", () => {
  assert.ok(!source.includes("dbscan"), "Should not reference dbscan");
  assert.ok(!source.includes("DBSCAN"), "Should not reference DBSCAN");
});

test("clusters.ts does not export internal helpers", () => {
  assert.ok(!source.includes("internalQuery"), "No internal queries");
  assert.ok(!source.includes("internalMutation"), "No internal mutations");
  assert.ok(!source.includes("action("), "No actions");
});

// --- pointInPolygon unit tests ---

test("pointInPolygon: point inside a triangle returns true", () => {
  const { pointInPolygon } = loadPointInPolygon();
  const polygon = [
    { lat: 0, lng: 0 },
    { lat: 4, lng: 0 },
    { lat: 2, lng: 4 },
  ];
  assert.ok(pointInPolygon({ lat: 2, lng: 1 }, polygon));
});

test("pointInPolygon: point outside a triangle returns false", () => {
  const { pointInPolygon } = loadPointInPolygon();
  const polygon = [
    { lat: 0, lng: 0 },
    { lat: 4, lng: 0 },
    { lat: 2, lng: 4 },
  ];
  assert.ok(!pointInPolygon({ lat: 5, lng: 5 }, polygon));
});

test("polygonCentroid: centroid of triangle is average", () => {
  const { polygonCentroid } = loadPointInPolygon();
  const polygon = [
    { lat: 0, lng: 0 },
    { lat: 3, lng: 0 },
    { lat: 0, lng: 3 },
  ];
  const centroid = polygonCentroid(polygon);
  assert.ok(Math.abs(centroid.lat - 1) < 0.01, `Expected lat ~1, got ${centroid.lat}`);
  assert.ok(Math.abs(centroid.lng - 1) < 0.01, `Expected lng ~1, got ${centroid.lng}`);
});

test("polygonCentroid: empty polygon returns {0,0}", () => {
  const { polygonCentroid } = loadPointInPolygon();
  const centroid = polygonCentroid([]);
  assert.equal(centroid.lat, 0);
  assert.equal(centroid.lng, 0);
});

test("polygonCentroid: single point returns the point", () => {
  const { polygonCentroid } = loadPointInPolygon();
  const centroid = polygonCentroid([{ lat: 43.5, lng: -80.5 }]);
  assert.equal(centroid.lat, 43.5);
  assert.equal(centroid.lng, -80.5);
});

test("boundingRadius: returns 0 for empty polygon", () => {
  const { boundingRadius } = loadPointInPolygon();
  const r = boundingRadius({ lat: 0, lng: 0 }, []);
  assert.equal(r, 0);
});

test("boundingRadius: returns max distance from center to vertices", () => {
  const { boundingRadius } = loadPointInPolygon();
  const center = { lat: 0, lng: 0 };
  const polygon = [
    { lat: 1, lng: 0 },
    { lat: 0, lng: 1 },
    { lat: -1, lng: 0 },
  ];
  const r = boundingRadius(center, polygon);
  // All vertices are ~111km from center; result should be > 100
  assert.ok(r > 100, `Expected > 100km, got ${r}`);
});
